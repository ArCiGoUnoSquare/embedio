{"name":"Embedio","tagline":"A tiny, cross-platform, module based web server","body":"EmbedIO - Unosquare Labs\r\n========================\r\n\r\nA tiny, cross-platform, module based, MIT-licensed web server\r\n\r\n* New Version: Network operations make heavy use of the relatively recent async/await pattern\r\n* Cross-platform (tested in Mono 3.10.x on Windows and on a custom Yocto image for the Raspberry Pi)\r\n* Extensible (Write your own modules like bearer token session handling, video streaming, UPnP, etc.)\r\n* Small memory footprint\r\n* Create REST APIs quickly with the built-in Web Api Module\r\n* Serve static files with 1 line of code (built-in module)\r\n* Handle sessions with the built-in LocalSessionWebModule\r\n* Web Sockets support (Not available on Mono though)\r\n\r\n*For detailed usage and REST API implementation, download the code and take a look at the Samples project*\r\n\r\nNuGet Installation:\r\n-------------------\r\n```\r\nPM> Install-Package EmbedIO\r\n```\r\n\r\nBasic Example:\r\n--------------\r\n\r\n*Please note the comments are the important part here. More info is available in the samples.*\r\n\r\n```csharp\r\nnamespace Company.Project\r\n{\r\n    using System;\r\n    using Unosquare.Labs.EmbedIO;\r\n    \r\n    public class Logger : Unosquare.Labs.EmbedIO.ILog\r\n    {\r\n        public void Info(object message)\r\n        {\r\n            InfoFormat(message.ToString(), null);\r\n        }\r\n\r\n        public void Error(object message)\r\n        {\r\n            ErrorFormat(message.ToString(), null);\r\n        }\r\n\r\n        public void Error(object message, Exception exception)\r\n        {\r\n            ErrorFormat(message.ToString(), null);\r\n            ErrorFormat(exception.ToString(), null);\r\n        }\r\n\r\n        private void WriteLine(ConsoleColor color, string format, params object[] args)\r\n        {\r\n            var current = Console.ForegroundColor;\r\n            Console.ForegroundColor = color;\r\n            Console.WriteLine(format, args);\r\n            Console.ForegroundColor = current;\r\n        }\r\n\r\n        public void InfoFormat(string format, params object[] args)\r\n        {\r\n            WriteLine(ConsoleColor.Blue, format, args);\r\n        }\r\n\r\n        public void WarnFormat(string format, params object[] args)\r\n        {\r\n            WriteLine(ConsoleColor.Yellow, format, args);\r\n        }\r\n\r\n        public void ErrorFormat(string format, params object[] args)\r\n        {\r\n            WriteLine(ConsoleColor.Red, format, args);\r\n        }\r\n\r\n        public void DebugFormat(string format, params object[] args)\r\n        {\r\n            WriteLine(ConsoleColor.Cyan, format, args);\r\n        }\r\n    }\r\n    \r\n    class Program\r\n    {\r\n        /// <summary>\r\n        /// Defines the entry point of the application.\r\n        /// </summary>\r\n        /// <param name=\"args\">The arguments.</param>\r\n        static void Main(string[] args)\r\n        {\r\n            var url = \"http://localhost:9696/\";\r\n            if (args.Length > 0)\r\n                url = args[0];\r\n\r\n            // Our web server is disposable. Note that if you don't want to use logging,\r\n            // there are alternate constructors that allow you to skip specifying an ILog object.\r\n            using (var server = new WebServer(url, new Logger()))\r\n            {\r\n                // First, we will configure our web server by adding Modules.\r\n                // Please note that order DOES matter.\r\n                // ================================================================================================\r\n                // If we want to enable sessions, we simply register the LocalSessionModule\r\n                // Beware that this is an in-memory session storage mechanism so, avoid storing very large objects.\r\n                // You can use the server.GetSession() method to get the SessionInfo object and manupulate it.\r\n                // You could potentially implement a distributed session module using something like Redis\r\n                server.RegisterModule(new Modules.LocalSessionModule());\r\n\r\n                // Here we setup serving of static files\r\n                server.RegisterModule(new Modules.StaticFilesModule(\"c:/inetpub/wwwroot\"));\r\n                // The static files module will cache small files in ram until it detects they have been modified.\r\n                server.Module<Modules.StaticFilesModule>().UseRamCache = true;\r\n                server.Module<Modules.StaticFilesModule>().DefaultExtension = \".html\";\r\n                // We don't need to add the line below. The default document is always index.html.\r\n                //server.Module<Modules.StaticFilesWebModule>().DefaultDocument = \"index.html\";\r\n                \r\n                // Once we've registered our modules and configured them, we call the RunAsync() method.\r\n                // This is a non-blocking method (it return immediately) so in this case we avoid\r\n                // disposing of the object until a key is pressed.\r\n                //server.Run();\r\n                server.RunAsync();\r\n\r\n                // Fire up the browser to show the content if we are debugging!\r\n#if DEBUG\r\n                var browser = new System.Diagnostics.Process() { \r\n                    StartInfo = new System.Diagnostics.ProcessStartInfo(url) { UseShellExecute = true } };\r\n                browser.Start();\r\n#endif\r\n                // Wait for any key to be pressed before disposing of our web server.\r\n                // In a service we'd manage the lifecycle of of our web server using\r\n                // something like a BackgroundWorker or a ManualResetEvent.\r\n                Console.ReadKey(true);\r\n            }\r\n\r\n            // Before exiting, we shutdown the logging subsystem.\r\n            Logger.Shutdown();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nREST API Example:\r\n-----------------\r\n\r\n*During server setup:*\r\n```csharp\r\nserver.RegisterModule(new WebApiModule());\r\nserver.Module<WebApiModule>().RegisterController<PeopleController>();\r\n```\r\n\r\n*And our controller class looks like:*\r\n\r\n```csharp\r\npublic class PeopleController : WebApiController\r\n{\r\n    [WebApiHandler(HttpVerbs.Get, \"/api/people/*\")]\r\n    public bool GetPeople(WebServer server, HttpListenerContext context)\r\n    {\r\n        try\r\n        {\r\n            var lastSegment = context.Request.Url.Segments.Last();\r\n            if (lastSegment.EndsWith(\"/\"))\r\n                return context.JsonResponse(People);\r\n\r\n            int key = 0;\r\n            if (int.TryParse(lastSegment, out key) && People.Any(p => p.Key == key))\r\n            {\r\n                return context.JsonResponse(People.FirstOrDefault(p => p.Key == key));\r\n            }\r\n\r\n            throw new KeyNotFoundException(\"Key Not Found: \" + lastSegment);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            return HandleError(context, ex, (int)HttpStatusCode.InternalServerError);\r\n        }\r\n    }\r\n    \r\n    protected bool HandleError(HttpListenerContext context, Exception ex, int statusCode = 500)\r\n    {\r\n        var errorResponse = new\r\n        {\r\n            Title = \"Unexpected Error\",\r\n            ErrorCode = ex.GetType().Name,\r\n            Description = ex.ExceptionMessage(),\r\n        };\r\n\r\n        context.Response.StatusCode = statusCode;\r\n        return context.JsonResponse(errorResponse);\r\n    }\r\n}\r\n```\r\n\r\nWeb Sockets Example:\r\n-----------------\r\n\r\n*During server setup:*\r\n```csharp\r\nserver.RegisterModule(new WebSocketsModule());\r\nserver.Module<WebSocketsModule>().RegisterWebSocketsServer<WebSocketsChatServer>(\"/chat\");\r\n```\r\n\r\n*And our web sockets server class looks like:*\r\n\r\n```csharp\r\n\r\n/// <summary>\r\n/// Defines a very simple chat server\r\n/// </summary>\r\npublic class WebSocketsChatServer : WebSocketsServer\r\n{\r\n\r\n    public WebSocketsChatServer()\r\n        : base(true, 0)\r\n    {\r\n        // placeholder\r\n    }\r\n\r\n    /// <summary>\r\n    /// Called when this WebSockets Server receives a full message (EndOfMessage) form a WebSockets client.\r\n    /// </summary>\r\n    /// <param name=\"context\">The context.</param>\r\n    /// <param name=\"rxBuffer\">The rx buffer.</param>\r\n    /// <param name=\"rxResult\">The rx result.</param>\r\n    protected override void OnMessageReceived(WebSocketContext context, byte[] rxBuffer, WebSocketReceiveResult rxResult)\r\n    {\r\n        var session = this.WebServer.GetSession(context);\r\n        foreach (var ws in this.WebSockets)\r\n        {\r\n            if (ws != context)\r\n                this.Send(ws, Encoding.UTF8.GetString(rxBuffer));\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets the name of the server.\r\n    /// </summary>\r\n    /// <value>\r\n    /// The name of the server.\r\n    /// </value>\r\n    public override string ServerName\r\n    {\r\n        get { return \"Chat Server\"; }\r\n    }\r\n\r\n    /// <summary>\r\n    /// Called when this WebSockets Server accepts a new WebSockets client.\r\n    /// </summary>\r\n    /// <param name=\"context\">The context.</param>\r\n    protected override void OnClientConnected(WebSocketContext context)\r\n    {\r\n        this.Send(context, \"Welcome to the chat room!\");\r\n        foreach (var ws in this.WebSockets)\r\n        {\r\n            if (ws != context)\r\n                this.Send(ws, \"Someone joined the chat room.\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// Called when this WebSockets Server receives a message frame regardless if the frame represents the EndOfMessage.\r\n    /// </summary>\r\n    /// <param name=\"context\">The context.</param>\r\n    /// <param name=\"rxBuffer\">The rx buffer.</param>\r\n    /// <param name=\"rxResult\">The rx result.</param>\r\n    protected override void OnFrameReceived(WebSocketContext context, byte[] rxBuffer, WebSocketReceiveResult rxResult)\r\n    {\r\n        return;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Called when the server has removed a WebSockets connected client for any reason.\r\n    /// </summary>\r\n    /// <param name=\"context\">The context.</param>\r\n    protected override void OnClientDisconnected(WebSocketContext context)\r\n    {\r\n        this.Broadcast(string.Format(\"Someone left the chat room.\"));\r\n    }\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}